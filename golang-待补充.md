# go/面试

- golang是值传递还是引用传递，值传递，map和channel通过封装传递的是指针副本，slice传递的是底层的值，类似引用行为

- golang是面向对象语言？是也不是，但它通过interface以及属性方法可以实现oop的继承、多态、封装

- 什么时候用指针结构体接收器或结构体接收器，三大原则，是否需要、大数据、修改结构体

- make和new的区别：本质上在于 make 函数在初始化时，会初始化 slice、chan、map 类型的内部数据结构，new 函数并不会，会返回指针。

- 进程、协程、线程；

  - 节省 CPU：避免系统内核级的线程频繁切换，造成的 CPU 资源浪费。好钢用在刀刃上。而协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。
  - 节约内存：在 64 位的Linux中，一个线程需要分配 8MB 栈内存和 64MB 堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。
  - 稳定性：前面提到线程之间通过内存来共享数据，这也导致了一个问题，任何一个线程出错时，进程中的所有线程都会跟着一起崩溃。
  - 开发效率：使用协程在开发程序之中，可以很方便的将一些耗时的IO操作异步化，例如写文件、耗时 IO 请求等。

- gm模型的缺点
  - 存在单一的全局 mutex（Sched.Lock）和集中状态管理： mutex 需要保护所有与 goroutine（G）交接（G.nextg）：工作者线程（M's）之间会经常交接可运行的 goroutine。
  - 上述可能会导致延迟增加和额外的开销。每个 M 必须能够执行任何可运行的 G，特别是刚刚创建 G 的 M。
  - 每个 M 都需要做内存缓存（M.mcache）：会导致资源消耗过大（每个 mcache 可以吸纳到 2M 的内存缓存和其他缓存），数据局部性差。
  - 频繁的线程阻塞/解阻塞： 在存在 syscalls 的情况下，线程经常被阻塞和解阻塞。这增加了很多额外的性能开销。

- 结构体可比较嘛？
  - 基本类型包含：slice、map、function 时，是不能比较的。若要强行比较，可用反射。

- 一个cpu两个goroutine其中一个死循环会打印结果吗？runtime.sysmon 方法会调用 retake 方法理一下两种场景：
  - 抢占阻塞在系统调用上的 P。
  - 抢占运行时间过长的 G。
