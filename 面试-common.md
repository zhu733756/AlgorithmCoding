### 计算机基础

#### 堆和栈

什么时候用堆？什么时候用栈？栈有什么作用？Golang 的变量在栈还是堆？堆、栈有没有上限？有的话和什么有关？

> 堆和栈有两种，数据类型中的堆栈和os中的堆栈内存分配。

> 数据结构中的堆用来做堆排序、最大堆、最小堆，栈则是先进后出的队列，通常用来实现单调栈、bfs遍历数辅助栈等。

> Stack memory内存,自动分配和释放，内存空间有限; Heap Memory内存, 手动分配和释放，空间是很大，几乎没有空间限制。

![img](https://tonybai.com/wp-content/uploads/understand-go-escape-analysis-by-example-2.jpg)

> 带有GC的编程语言会对位于堆上的对象进行自动管理。当某个对象不可达时（即没有其对象引用它时），它将会被回收并被重用。GC不是免费的，它给程序带来的性能损耗是不可忽视的，尤其是当堆内存上有大量待扫描的堆内存对象时，将会给GC带来过大的压力。

> **逃逸分析（escape analysis）就是在程序编译阶段根据程序代码中的数据流，对代码中哪些变量需要在栈上分配，哪些变量需要在堆上分配进行静态分析的方法**。

> 注：有一点需要明确，那就是静态逃逸分析也无法确定的对象会被放置在堆上，后续精确的GC会处理这些对象，这样最大程度保证了代码的安全性。

> 然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。

> 通过-gcflags “-m -l”来执行逃逸分析
>
> 不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销可能更大

#### 数据结构

Slice空间时怎么扩容的？

> 根据申请空间大小，如果申请空间大于原来slice的容量两倍，直接给容量增加到申请的值，反之，如果原来slice的长度len小于1024则会double一下，最后，如果大于1024则会按照原来cap的0.25递增直至超过申请的cap。

Golang的map是什么数据结构？遍历是否有序， 什么是 Hash 表？ Hash 表的查询效率？ 解决碰撞有什么方法？

> golang的map是hashmap实现的，用hmap表示头，bmap表示桶，buckets是这个数组的头指针(起始地址), bmap是每个bucket的实体。每个bucket有一个长度为8的数组叫做tophash, 他存储了8个key的高八位的值, 这样当我们找的时候, 先用key hash的低八位找到对应的桶, 再匹配key高8位值找到对应的tophash, 如果正确了再去找对应的key是否相等。
>
> overflow溢出率是指平均一个bucket有多少个kv的时候会溢出。bytes/entry是指平均存一个kv需要额外存储多少字节的数据。hitprobe是指找一个存在的key平均需要找多少次。missprobe是指找一个不存在的key平均需要找多少次。选取6.5是为了平衡这组数据。
>
> o(1)
>
> 线性探测法包括二次和指数，拉链法

#### 线程、进程、协程

上下文切换

> 在一个进程中，当一个线程任务执行几毫秒后，会由操作系统的内核（负责管理各个任务）进行调度，通过硬件的计数器中断处理器，该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务

> 引起线程上下文切换的原因如下 

（1）当前正在执行的任务完成，系统的CPU正常调度下一个任务。
（2）当前正在执行的任务遇到I/O等阻塞操作，调度器挂起此任务，继续调度下一个任务。
（3）多个任务并发抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续调度下一个任务。
（4）用户的代码挂起当前任务，比如线程执行yield()方法，让出CPU。
（5）硬件中断


线程是否越多越好吗？ 线程切换消耗大不大？

> 不是. 有名的单线程io多路复用性能就很高. 比如低版本的redis. 线程切换需要消耗cpu时间以及切换线程依赖的上下文, 如果是同一个进程的线程来说,内存一般是共享的,切换上下文的代价要小于不同进程的线程上下文切换.
>
> 协程采用的是非抢占式、协调式的, 一般来说不会受到cpu掉的时间的影响.
>
> - 用户态
> - goroutine 所占用的内存小,2-4k 是需要连续的内存块。
> - 栈管理

协程是否越多越好吗？协程多大为好

> 单机的 goroutine 数量只要控制在限额以下的，都可以认为是 “合理”。
>
> 真实场景得看具体里面跑的是什么，跑的如果是 “资源怪兽”，只运行几个 Goroutine 都可以跑死。
>
> 因此想定义 “预算”，就得看跑的什么了。

### 网络

#### TCP协议

TCP 建立过程是怎样的，最要的工作是什么？

> 三次握手，建议双工连接，最主要的工作是协商序列号

TCP关闭过程，为什么要挥手5？

> 因为TCP 是可以双向传输数据的，也就是[全双工协议](https://www.zhihu.com/search?q=全双工协议&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2306127873})。
>
> 双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。
>
> 说明：主动断开方要等对端处理完数据后才能发送fin报文，这样主动断开方就能发送ack，也就是第四次挥手，被动方会释放连接，进入可用状态。

![img](https://raw.githubusercontent.com/zhu733756/bedpic/main/images/v2-92888df73d4608c0a1970c5032612c48_720w.jpg)

Client 主动关闭链接， `TIME_WAIT` 发生在那端？服务器有很多 TimeWait 一般是什么情况

> 主动断开方会发生time_wait, 需要等待2msl的时间， 等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。
>
> 有很多的time_wait证明服务独单主动关闭连接，存在很多的短链接。

Client 和 Server 已建立了 TCP 连接， Client 正在调用 Read 阻塞，Server 进程崩溃后，Client 会怎样? 

> 进程崩溃，操作系统会关闭文件描述符，Sever 进入主动关闭流程。

TCP是可靠传输，应用层是否还需要做校验? TCP如何保证数据的正确性? 这个校验机制能够确保数据传输不会出错吗？

> TCP的首部字段中有一个字段是校验和，发送方将伪首部、TCP首部、TCP数据使用累加和校验的方式计算出一个数字，然后存放在首部的校验和字段里，接收者收到TCP包后重复这个过程，然后将计算出的校验和和接收到的首部中的校验和比较，如果不一致则说明数据在传输过程中出错。**这就是TCP的数据校验机制**。
>
> 因为这种校验方式是累加和，也就是将一系列的数字（TCP协议规定的是数据中的每16个比特位数据作为一个数字）求和后取末位。假如在传输的过程中有前后两个16比特位的数据前后颠倒了, 那么校验和的计算结果和颠倒之前是一样的，那么接收端肯定无法检查出这是错误的数据。
>
> 既然TCP自带的校验算法并不靠谱，我们就需要在应用层自己建立一套新的数据校验机制, 比如传递md5。

超时重发：

> 超时重发是指在重发数据之前，等待确认应答到来的那个间隔时间。如果超过 RTT（往返时间），仍未收到确认应答，发送端将进行数据重发。过大的 RTT 会导致 TCP 重传非常慢，降低传输的速度；过小的 RTT 会导致 TCP 频繁重传，降低资源的使用效率。如果发送端收到连续 3 次同一个确认应答，就会将对应的数据进行重发。这种机制比超时管理更高效，也被称为**高速重发机制**。

窗口控制

> TCP 是以 1 个段为单位，每发一个段进行一次确认应答。如果包的往返时间越长，通信性能就越低。为解决这个问题，TCP 引入了**窗口**的概念。确认应答不再是每个分段，而是以窗口的大小进行确认，转发时间被大幅度的缩短。

流控制

> 接收端处于高负荷状态时，可能无法处理接收的数据，并丢弃数据，就会触发重发机制，导致网络流量无端浪费。如果窗口更新的报文丢失，可能会导致无法继续通信。为避免这个问题，发送端主机会时不时的发送一个叫**窗口探测**的数据段，此数据段仅含一个字节以获取最新的窗口大小信息。

### HTTP 协议

简述 http 协议格式，文本协议能不能传输二进制？http 可传输图片的方法

> http 协议格式规定了浏览器与服务器之间的请求和响应的格式与规则，它是万维网上能够可靠地交换文件的重要基础。
>
> 可以传输，比如图片。
>
> content-type

http 与 https 关系是什么？简述 https 协议作用

> https 是基于http的安全超文本传输协议，经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

描述出 https 握手过程的加分 

> - TCP 三次同步握手
> - 客户端验证服务器数字证书
> - DH 算法协商对称加密算法的密钥、hash 算法的密钥
> - SSL 安全加密隧道协商完成
> - 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

什么是 http 中 的 keepalive，怎样做到 keepalive ？

> http1.1 才支持keepAlive 可以简单理解为一种状态保持或重用机制，比如当一条连接建立后，我们不想它立刻被关闭，如果实现了 KeepAlive 机制，就可以通过它来实现连接的保持

http2 多路复用, 为什么HTTP/1.1不能实现“多路复用”？

> HTTP/1.1中的消息是“管道串形化”的：只有等一个消息完成之后，才能进行下一条消息；而HTTP/2中多个消息交织在了一起，这无疑提高了“通信”的效率。这就是多路复用：**在一个HTTP的连接上，多路“HTTP消息”同时工作**。**HTTP/2是基于二进制“帧”的协议，HTTP/1.1是基于“文本分割”解析的协议。** 帧是对数据的封装，1.1争对换行符分割；HTTP/2 通过支持标头字段压缩和在同一连接上 进行多个并发交换，让应用更有效地利用网络资源，减少 感知的延迟时间。具体来说，它可以对同一连接上的请求和响应消息进行交错 发送并为 HTTP 标头字段使用 有效编码。 

### 数据库

#### 索引知识

数据库索引使用了什么数据结构？为什么要使用这个数据结构?

> mysql使用b+树，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。b+树非常符合磁盘按页读取特性，根节点存储指针，叶子节点存储数据。
>
> 可以有效提高读写性能，接近于二分法。

一个表的字符串字段 A 已经建立了索引，使用查询条 A == ‘abc’ 是否能用上索引？使用查询条A != ‘abc’ 是否能用上索引？为什么？

> https://juejin.cn/post/6844903921450745863

那既然`IS NULL`、`IS NOT NULL`、`!=`这些条件都可能使用到索引，那到底什么时候索引，什么时候采用全表扫描呢？

>本质上都是优化器去计算一下对应的二级索引数量占所有记录数量的比值而已.
>
>对于使用二级索引进行查询来说，成本组成主要有两个方面：
>
>- 读取二级索引记录的成本
>- 将二级索引记录执行回表操作，也就是到聚簇索引中找到完整的用户记录的操作所付出的成本。

有个表 a 有主键 id， 说明一下 `select * from a order by id desc limit 10, 1` 和 `select*from a order by id desc limit 100000, 1` 的效率差别?

> offset多大就需要遍历多少row

用什么办法遍历一个有主键 id 的 3 亿数据表

> 1内存 2 根据主键分批查询，绕过limit的分页机制 3 先查id，再获取数据

#### 算法

有一个 100 万个不相等的乱序的整数， 用最快方法将其分成相等的两部分，要求前一部分每个数都比后一部分每个数小？

> 使用快速排序，取得第一个数值，比较后将小的放左边，大的放右边，再比较两边的长度，对长度大的一边进行上面的操作。算法的复杂度应该为o(n)

在内存中有 100 组有序数组， 每组 10 万个元素，用最快方法将他们合并成一个有序的数组。

> 使用堆

如何判断一个链表有闭环

> 使用两个指针，分别以不同的速度向前遍历，一个以单个元素为步长，另一个以两个元素为步长，如果两个元素步长的指针追上了后面的指针，这便证明该链表中存在环。这样，只需要额外的两个空间，空间复杂度为O(1)。

### Golang

如果多个线程并发读写一个 map，会产生什么结果？为什么会产生这种结果？有什么办法保证并发安全？

> panic，因为map不是并发安全的数据类型。加锁、要求读取性能可使用sync.map（写多不推荐）、改用分片map也是有锁的

Golang 中对一个 int64 进行高并发更新（增减），有什么办法保证并发安全？

> atomic CAS/channel/mutex

描述 goroutine 调度、切换机制。

> GPM, 每一个local 处理器p代表着运行上下文，m对应着物理线程，G代表着本地的groutine队列。
>
> 切换机制：golang基于io封装了异步函数，当监听到阻塞时会切换底层的m，使更多的groutine能被处理到。

Golang chan特性， 底层是怎么实现的？

> chan底层是用了锁+双向队列实现。线程安全/先进先出/跨goroutine栈可以直接进行读写

> channel分为非缓存channel与缓存channel。

什么时候会阻塞，怎么判断会阻塞？

> 投递前可cap、len函数判断是否相等，但要锁住。第2个方法是用select default，实际编程中select必需加 default处理逻辑。

### Redis

string、list、set、zset、hash，每种数据结构的使用场景，实现原理

> string: 分布式锁、token
>
> list：消息队列
>
> set：集合，交集、差集、并集
>
> zset：根据score来排序
>
> hash：hash k、v

 Redis 用法如何用 Redis 实现一个分布式锁

> SETNX，用 Lua 脚本可保持原子性。原生命令时原子的，`Pipeline`是非原子的。

Redis对设置了TTL的key，是如何实现key的过期的？

> 主动随机抽样轮询和被动删除。

Redis的key淘汰策略有哪些？ 各有什么特点？LRU 算法的流程是什么

> 常用的有volatile-lru、volatile-ttl。最近最少使用淘汰。

redis 有没有 stop the world 问题？什么时候会出现？为什么？

> 低版本的redis是单进程的，单个任务执行时间长会影响任务执行，比如持久化、删除大量key时候会出现抖动。

### 系统设计

输入一个长网址，编码返回一个短网址？如何通过短网址找到长网址？跳转用301还是302？

> 用ID生成器生成一个64bit整数

> key,value mysql和redis都可以。

> 301是永久重定向，302是临时重定向。如果需要统计点击次数，选择302会增加压力，但有利于获取埋点数据。

> 补充：小型服务要求可用mysql自增主键id发号，大型服务考虑用分布式发号器，多个服务器可用一致性hash来发号。发号要求：全局唯一、体积要小、时间有序。

